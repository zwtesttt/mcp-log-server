package main

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/mark3labs/mcp-go/mcp"
	"github.com/mark3labs/mcp-go/server"
)

// ç¯å¢ƒé…ç½®
var environments = map[string]string{
	"dev":     "mm01.sca.im",
	"test":    "test-server.company.com",
	"staging": "staging-server.company.com",
	"prod":    "prod-server.company.com",
}

// æ—¥å¿—æ–‡ä»¶é…ç½®
var logFiles = map[string]string{
	"blackhole": "/var/log/app/blackhole.log",
	"oms":       "/data/develop/oms/logs/oms.log",
}

func main() {
	// åˆ›å»ºMCPæœåŠ¡å™¨
	mcpServer := server.NewMCPServer(
		"Log Command Generator",
		"1.0.0",
		server.WithToolCapabilities(true),
	)

	// æ·»åŠ ç”Ÿæˆæ—¥å¿—æŸ¥çœ‹å‘½ä»¤çš„å·¥å…·
	mcpServer.AddTool(mcp.NewTool("generate_log_command",
		mcp.WithDescription("ç”Ÿæˆæ—¥å¿—æŸ¥çœ‹å‘½ä»¤"),
		mcp.WithString("environment",
			mcp.Description("ç¯å¢ƒ (dev/test/staging/prod)"),
			mcp.Required(),
		),
		mcp.WithString("log_type",
			mcp.Description("æ—¥å¿—ç±»å‹ (blackhole/é»‘æ´/oms/api/error/é”™è¯¯)"),
			mcp.Required(),
		),
		mcp.WithString("keyword",
			mcp.Description("æœç´¢å…³é”®è¯ï¼ˆå¯é€‰ï¼‰"),
		),
		mcp.WithString("lines",
			mcp.Description("æ˜¾ç¤ºè¡Œæ•°ï¼ˆé»˜è®¤1000è¡Œï¼‰"),
			mcp.DefaultString("1000"),
		),
	), handleGenerateLogCommand)

	// æ·»åŠ ç¯å¢ƒåˆ—è¡¨å·¥å…·
	mcpServer.AddTool(mcp.NewTool("list_environments",
		mcp.WithDescription("åˆ—å‡ºæ‰€æœ‰å¯ç”¨ç¯å¢ƒ"),
	), handleListEnvironments)

	// å¯åŠ¨æœåŠ¡å™¨
	log.Println("Starting Log Command Generator MCP Server...")
	if err := server.ServeStdio(mcpServer); err != nil {
		log.Fatalf("Server error: %v", err)
	}
}

func handleGenerateLogCommand(
	ctx context.Context,
	request mcp.CallToolRequest,
) (*mcp.CallToolResult, error) {
	arguments := request.GetArguments()

	// è·å–ç¯å¢ƒ
	env, ok := arguments["environment"].(string)
	if !ok {
		return nil, fmt.Errorf("ç¯å¢ƒå‚æ•°æ— æ•ˆ")
	}

	server, exists := environments[env]
	if !exists {
		return nil, fmt.Errorf("æœªçŸ¥ç¯å¢ƒ: %s", env)
	}

	// è·å–æ—¥å¿—ç±»å‹
	logType, ok := arguments["log_type"].(string)
	if !ok {
		return nil, fmt.Errorf("æ—¥å¿—ç±»å‹å‚æ•°æ— æ•ˆ")
	}

	logPath, exists := logFiles[logType]
	if !exists {
		return nil, fmt.Errorf("æœªçŸ¥æ—¥å¿—ç±»å‹: %s", logType)
	}

	// è·å–è¡Œæ•°
	lines := "1000"
	if l, ok := arguments["lines"].(string); ok && l != "" {
		lines = l
	}

	// æ„å»ºåŸºç¡€å‘½ä»¤
	var command strings.Builder
	command.WriteString(fmt.Sprintf("ssh -t develop@%s -p 59822 'tail -%s %s", server, lines, logPath))

	// æ·»åŠ å…³é”®è¯è¿‡æ»¤
	if keyword, ok := arguments["keyword"].(string); ok && keyword != "" {
		command.WriteString(fmt.Sprintf(" | grep -i \"%s\"", keyword))
	}

	command.WriteString("'")

	finalCommand := command.String()

	return &mcp.CallToolResult{
		Content: []mcp.Content{
			mcp.TextContent{
				Type: "text",
				Text: fmt.Sprintf("ğŸ”§ **ç”Ÿæˆçš„æ—¥å¿—æŸ¥çœ‹å‘½ä»¤**\n\n**ç¯å¢ƒ**: %s\n**æ—¥å¿—æ–‡ä»¶**: %s\n**è¡Œæ•°**: %s\n\n```bash\n%s\n```\n\nğŸ’¡ å¤åˆ¶ä¸Šè¿°å‘½ä»¤åˆ°ç»ˆç«¯æ‰§è¡Œå³å¯æŸ¥çœ‹æ—¥å¿—",
					env, logPath, lines, finalCommand),
			},
		},
	}, nil
}

func handleListEnvironments(
	ctx context.Context,
	request mcp.CallToolRequest,
) (*mcp.CallToolResult, error) {
	var result strings.Builder
	result.WriteString("ğŸŒ **å¯ç”¨ç¯å¢ƒåˆ—è¡¨**\n\n")

	for env, server := range environments {
		result.WriteString(fmt.Sprintf("- **%s**: %s\n", env, server))
	}

	return &mcp.CallToolResult{
		Content: []mcp.Content{
			mcp.TextContent{
				Type: "text",
				Text: result.String(),
			},
		},
	}, nil
}
